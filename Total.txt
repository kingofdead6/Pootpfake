i have this code make it more larger and add to it all the possible functions that might be asked and needed considering this exercice text 
A transport company wants to design and implement an application to manage the public
transportation system of a city. Each mode of transport is characterized by its code, the
transport line it serves, the type of power supply (Diesel, Electricity, Hybrid), and the number of
kilometers traveled.

To travel, a passenger is required to obtain a fare medium from the station counter (a fare
medium is an item that grants access to transport services such as tickets or passes). It can be
paid in cash, with a Dahabia card, ar via the BaridiMob application. A fare medium is
characterized by its identifier, purchase date and time, served zones (center, periphery, or both),
activation date and time (first trip), price, and payment method (cash, Dahabia card, BaridiMob
app). Before boarding a mode of transport, the passenger validates their fare medium using a
magnetic reader at the station, which then grants access. Each station has a counter and at least
one magnetic reader. A passenger can buy multiple fare media.

The company wants to identify each passenger by a number and record the station where the
purchase was made for statistical purposes.

A transport line is served by a single mode of transport and follows a fixed route with multiple
stations. It is defined by a unique number, a total length in kilometers, an ordered list of stations
where it stops (at least three stations), and an operating schedule (first and last departures).
A station is a stopping point on a transport line and is defined by a unique code, a name, the
municipality where it is located, its location zone (city center or periphery), a single counter for
fare media purchases, and at least one magnetic reader for fare validation. A station can be
served by multiple lines.

Stations and modes of transport can be either operational (in service) or suspended
(temporarily deactivated for maintenance reasons).

to ensure quality of service, the company allows passengers to report issues via the application
related to their travel experience. Each complaint is analyzed within 24 hours of being reported.
It may be rejected if unfounded, or approved and then sent for processing. Each complaint is 
identified by a number, the person who submitted it (either a passenger or an employee of the
company : station agent or driver), an optional short description of the issue, and the report
date. Each complaint is linked to the station where it was reported. If the complaint relates to a
mode of transport, the person submitting it can specify the departure or arrival station, allowing
the relevant service at that station to process the request.A person can report multiple complaints if they wish.

We identify three types of complaints: (1) Technical complaints: These concern technical
malfunctions of transport modes or stations. They are characterized by the type of issue, which
can be: inaccurate/missing schedule displays, air conditioning/heating issues in the vehicle or
the station, sound system problems, defective fare reader; the mode of transport or the station
concerned by the technical issue, along with its severity level (low, medium, high). The severity
is assessed by the station's service handling the complaint (2) Fare payment complaints: These
relate to issues with financial transactions. They are characterized by the amount involved and
the payment method used. (3) Service and safety complaints: These complaints relate to
interactions with staff and passenger safety. They are categorized by the type of issue, which
may involve inappropriate behavior, assault, or theft.

If a mode of transport or a station receives more than three approved technical complaints with
a high severity level within 24 hours, it is automatically suspended for inspection and
maintenance. The suspension is lifted once all complaints have been processed by the relevant
services, and their status is updated to 'resolved'. During the suspension and after the
reactivation of stations or modes of transport, passengers are informed through announcements
displayed at stations and on the application.

The system must provide the following features:
Manage fare medium sales transactions
   The system must allow for displaying the purchase history of fare media by station.
   It must also support generating revenue reports by payment method (cash,Dahabia card, BaridiMob app).

Analyze transportation usage
   the system must record the number of visitors - defined as passengers who have validated a fare medium - entering a station during a given time period.
   It may also provide statistics on peak and off-peak days of the week
Manage the status of transport modes and stations
   The system must allow for displaying the number and types of complaints per station or mode of transport.
   It must also provide the total number of suspended stations and modes of transport


this is my files structure 

src/
├── enums/
│   ├── ComplaintStatus.java
│   ├── ComplaintType.java
│   ├── PaymentMethod.java
│   ├── PowerSupply.java
│   ├── ServiceSafetyIssueType.java
│   ├── SeverityLevel.java
│   ├── TechnicalIssueType.java
│   └── Zone.java
├── models/
│   ├── Complaint.java
│   ├── FareMedium.java
│   ├── FarePaymentComplaint.java
│   ├── Person.java
│   ├── Passenger.java
│   ├── Employee.java
│   ├── StationAgent.java
│   ├── Driver.java
│   ├── ServiceSafetyComplaint.java
│   ├── Station.java
│   ├── TechnicalComplaint.java
│   ├── TransportLine.java
│   └── TransportMode.java
└── services/
    ├── ComplaintService.java
    ├── FareService.java
    ├── ReportService.java
    |── SystemManager.java
    |__ NotificationService.java 
```

package enums;

public enum ComplaintStatus {
    PENDING, APPROVED, REJECTED, RESOLVED
}
package enums;

public enum ComplaintType {
    TECHNICAL, FARE_PAYMENT, SERVICE_SAFETY
}

package enums;

public enum PaymentMethod {
    CASH, DAHABIA_CARD, BARIDIMOB_APP
}

package enums;

public enum PowerSupply {
    DIESEL, ELECTRICITY, HYBRID
}

package enums;

public enum ServiceSafetyIssueType {
    BEHAVIOR, ASSAULT, THEFT
}

package enums;

public enum ServiceSafetyIssueType {
    BEHAVIOR, ASSAULT, THEFT
}package enums;

public enum SeverityLevel {
    LOW, MEDIUM, HIGH
}

package enums;

public enum TechnicalIssueType {
    SCHEDULE_DISPLAY, AIR_CONDITIONING, SOUND_SYSTEM, FARE_READER , GENERAL_FAILURE
}

package enums;

public enum Zone {
    CENTER, PERIPHERY, BOTH
}
package models;

import java.time.LocalDateTime;
import enums.ComplaintStatus;
import enums.SeverityLevel;

public abstract class Complaint {
    private int id;
    private Person submitter;
    private String description;
    private LocalDateTime reportDate;
    private Station station;
    private ComplaintStatus status;
    private Station departureStation;
    private Station arrivalStation;
    private SeverityLevel severity; // Added field

    public Complaint(int id, String description, Station station) {
        this.id = id;
        this.description = description;
        this.station = station;
        this.reportDate = LocalDateTime.now();
        this.status = ComplaintStatus.PENDING;
        this.severity = SeverityLevel.MEDIUM; // Default severity
    }

    public void setSubmitter(Person submitter) {
        this.submitter = submitter;
    }

    public void setStatus(ComplaintStatus status) {
        this.status = status;
    }

    public void setDate(LocalDateTime date) {
        this.reportDate = date;
    }

    public void setSeverity(SeverityLevel severity) { // Added setter
        this.severity = severity;
    }

    public abstract void processComplaint();

    // Getters
    public int getId() { return id; }
    public Person getSubmitter() { return submitter; }
    public String getDescription() { return description; }
    public LocalDateTime getReportDate() { return reportDate; }
    public Station getStation() { return station; }
    public ComplaintStatus getStatus() { return status; }
    public Station getDepartureStation() { return departureStation; }
    public Station getArrivalStation() { return arrivalStation; }
    public SeverityLevel getSeverity() { return severity; } // Added getter

    public void setDepartureStation(Station departureStation) {
        this.departureStation = departureStation;
    }

    public void setArrivalStation(Station arrivalStation) {
        this.arrivalStation = arrivalStation;
    }
}package models;

import enums.ComplaintStatus;

public class Driver extends Employee {
    private TransportMode assignedTransport;
    
    public Driver(int id, String name, Station station, TransportMode transport) {
        super(id, name, station);
        this.assignedTransport = transport;
    }
    
    @Override
    public void processComplaint(Complaint complaint) {
        if (complaint instanceof TechnicalComplaint) {
            TechnicalComplaint techComplaint = (TechnicalComplaint) complaint;
            if (techComplaint.getTransport() == assignedTransport) {
                complaint.setStatus(ComplaintStatus.PENDING);
                assignedStation.addComplaint(complaint);
            }
        }
    }

    public TransportMode getAssignedTransport() {
        return assignedTransport;
    }
}package models;

public abstract class Employee extends Person {
    protected Station assignedStation;
    
    public Employee(int id, String name, Station station) {
        super(id, name);
        this.assignedStation = station;
    }
    
    public abstract void processComplaint(Complaint complaint);

    public Station getAssignedStation() {
        return assignedStation;
    }
}package models;

import java.time.LocalDateTime;
import enums.PaymentMethod;
import enums.Zone;

public class FareMedium {
    private int id;
    private String code;
    private LocalDateTime purchaseDateTime;
    private Zone zones;
    private LocalDateTime activationDateTime;
    private double price;
    private PaymentMethod paymentMethod;
    private Station purchaseStation;

    public FareMedium(int id, String code, Zone zones, double price, PaymentMethod paymentMethod, LocalDateTime purchaseDateTime) {
        this.id = id;
        this.code = code;
        this.zones = zones;
        this.price = price;
        this.paymentMethod = paymentMethod;
        this.purchaseDateTime = purchaseDateTime;
    }

    public void validate() {
        if (activationDateTime == null) {
            activationDateTime = LocalDateTime.now();
        }
    }

    public void setPurchaseStation(Station station) {
        this.purchaseStation = station;
    }

    public void setPurchaseDateTime(LocalDateTime purchaseDateTime) {
        this.purchaseDateTime = purchaseDateTime;
    }

    public void setActivationDateTime(LocalDateTime activationDateTime) { // Added
        this.activationDateTime = activationDateTime;
    }

    // Getters
    public int getId() { return id; }
    public String getCode() { return code; }
    public LocalDateTime getPurchaseDateTime() { return purchaseDateTime; }
    public Zone getZones() { return zones; }
    public LocalDateTime getActivationDateTime() { return activationDateTime; }
    public double getPrice() { return price; }
    public PaymentMethod getPaymentMethod() { return paymentMethod; }
    public Station getPurchaseStation() { return purchaseStation; }

    public void setCode(String code) { this.code = code; }
}package models;

import enums.PaymentMethod;

public class FarePaymentComplaint extends Complaint {
    private double amount;
    private PaymentMethod paymentMethod;

    public FarePaymentComplaint(int id, String description, Station station, double amount, PaymentMethod paymentMethod) {
        super(id, description, station);
        this.amount = amount;
        this.paymentMethod = paymentMethod;
    }

    @Override
    public void processComplaint() {
        // Specific processing for fare payment complaints
        // Could involve refund processing or payment verification
    }

    // Getters
    public double getAmount() { return amount; }
    public PaymentMethod getPaymentMethod() { return paymentMethod; }
}package models;

import java.util.ArrayList;
import java.util.List;

public class Passenger extends Person {
    private List<FareMedium> fareMedia;
    
    public Passenger(int id, String name) {
        super(id, name);
        this.fareMedia = new ArrayList<>();
    }
    
    public void purchaseFareMedium(Station station, FareMedium fareMedium) {
        station.sellFareMedium(this, fareMedium);
        fareMedia.add(fareMedium);
    }
    
    public void validateFareMedium(FareMedium fareMedium) {
        fareMedium.validate();
    }
    
    public void submitComplaint(Complaint complaint) {
        complaint.setSubmitter(this);
    }

    public List<FareMedium> getFareMedia() {
        return fareMedia;
    }
}package models;

public abstract class Person {
    protected int id;
    protected String name;
    
    public Person(int id, String name) {
        this.id = id;
        this.name = name;
    }

    public int getId() {
        return id;
    }

    public String getName() {
        return name;
    }
}package models;

import enums.ServiceSafetyIssueType;

public class ServiceSafetyComplaint extends Complaint {
    private ServiceSafetyIssueType issueType;
    
    // Existing constructor
    public ServiceSafetyComplaint(int id, String description, Station station, 
                                 ServiceSafetyIssueType issueType) {
        super(id, description, station);
        this.issueType = issueType;
    }
    
    // New constructor to match Main class usage
    public ServiceSafetyComplaint(int id, String description, Station station) {
        super(id, description, station);
        this.issueType = ServiceSafetyIssueType.THEFT; // Default to THEFT as per Main's description
    }
    
    @Override
    public void processComplaint() {
        // Specific processing for safety complaints
        // Could involve HR actions, security measures, etc.
    }

    // Getters
    public ServiceSafetyIssueType getIssueType() { return issueType; }
}package models;

import java.util.ArrayList;
import java.util.List;
import enums.Zone;
import services.NotificationService;

public class Station {
    private String code;
    private String name;
    private String municipality;
    private Zone zone;
    private boolean isSuspended;
    private List<TransportLine> lines;
    private List<Complaint> complaints;
    private List<FareMedium> soldFareMedia;
    private List<FareMedium> validatedFareMedia;
    private int magneticReaderCount;
    
    public Station(String code, String name, String municipality, Zone zone, int magneticReaderCount) {
        if (magneticReaderCount < 1) {
            throw new IllegalArgumentException("Station must have at least one magnetic reader");
        }
        this.code = code;
        this.name = name;
        this.municipality = municipality;
        this.zone = zone;
        this.isSuspended = false;
        this.lines = new ArrayList<>();
        this.complaints = new ArrayList<>();
        this.soldFareMedia = new ArrayList<>();
        this.validatedFareMedia = new ArrayList<>();
        this.magneticReaderCount = magneticReaderCount;
    }
    
    public void sellFareMedium(Passenger passenger, FareMedium fareMedium) {
        if (!isSuspended) {
            passenger.getFareMedia().add(fareMedium);
            soldFareMedia.add(fareMedium);
        } else {
            throw new IllegalStateException("Cannot sell fare media at suspended station");
        }
    }
    
    public void validateFareMedium(FareMedium fareMedium) {
        if (!isSuspended) {
            fareMedium.validate();
            validatedFareMedia.add(fareMedium);
        } else {
            throw new IllegalStateException("Cannot validate fare media at suspended station");
        }
    }
    
    public void suspend() {
        this.isSuspended = true;
        NotificationService.notifyPassengers("Station " + name + " is suspended for maintenance.");
    }
    
    public void reactivate() {
        this.isSuspended = false;
        NotificationService.notifyPassengers("Station " + name + " is back in service.");
    }
    
    public void addComplaint(Complaint complaint) {
        complaints.add(complaint);
    }
    
    public void addTransportLine(TransportLine line) {
        lines.add(line);
    }

    // Getters and setters
    public String getCode() { return code; }
    public String getName() { return name; }
    public String getMunicipality() { return municipality; }
    public Zone getZone() { return zone; }
    public boolean isSuspended() { return isSuspended; }
    public List<TransportLine> getLines() { return lines; }
    public List<Complaint> getComplaints() { return complaints; }
    public List<FareMedium> getSoldFareMedia() { return soldFareMedia; }
    public List<FareMedium> getValidatedFareMedia() { return validatedFareMedia; }
    public int getMagneticReaderCount() { return magneticReaderCount; }
}package models;

import java.time.LocalDateTime;

import enums.ComplaintStatus;

public class StationAgent extends Employee {
    public StationAgent(int id, String name, Station station) {
        super(id, name, station);
    }
    
    public void sellFareMedium(Passenger passenger, FareMedium fareMedium) {
        fareMedium.setPurchaseStation(assignedStation);
        fareMedium.setPurchaseDateTime(LocalDateTime.now());
        passenger.purchaseFareMedium(assignedStation, fareMedium);
    }
    
    @Override
    public void processComplaint(Complaint complaint) {
        complaint.setStatus(ComplaintStatus.PENDING);
        assignedStation.addComplaint(complaint);
    }
}package models;

import enums.SeverityLevel;
import enums.TechnicalIssueType;

public class TechnicalComplaint extends Complaint {
    private TechnicalIssueType issueType;
    private TransportMode transport;
    private SeverityLevel severity;

    public TechnicalComplaint(int id, String description, Station station,
                             TechnicalIssueType issueType, TransportMode transport) {
        super(id, description, station);
        this.issueType = issueType;
        this.transport = transport;
        this.severity = SeverityLevel.MEDIUM; // Default severity
    }

    @Override
    public void processComplaint() {
        // Specific processing for technical complaints
        if (severity == SeverityLevel.HIGH && transport != null) {
            transport.suspend(); // Ensure TransportMode has suspend()
        }
    }

    // Getters and setters
    public TechnicalIssueType getIssueType() { return issueType; }
    public TransportMode getTransport() { return transport; }
    public SeverityLevel getSeverity() { return severity; }

    public void setSeverity(SeverityLevel severity) {
        this.severity = severity;
    }
}package models;

import java.time.LocalTime;
import java.util.List;

public class TransportLine {
    private int number;
    private double length;
    private List<Station> stations;
    private LocalTime firstDeparture;
    private LocalTime lastDeparture;
    
    public TransportLine(int number, double length, List<Station> stations, 
                        LocalTime firstDeparture, LocalTime lastDeparture) {
        if (stations.size() < 3) {
            throw new IllegalArgumentException("Transport line must have at least three stations");
        }
        this.number = number;
        this.length = length;
        this.stations = stations;
        this.firstDeparture = firstDeparture;
        this.lastDeparture = lastDeparture;
    }

    // Getters
    public int getNumber() { return number; }
    public double getLength() { return length; }
    public List<Station> getStations() { return stations; }
    public LocalTime getFirstDeparture() { return firstDeparture; }
    public LocalTime getLastDeparture() { return lastDeparture; }
}package models;

import enums.PowerSupply;

public class TransportMode {
    private String code;
    private TransportLine line;
    private PowerSupply powerSupply;
    private double kilometersTraveled;
    private boolean isSuspended;
    
    public TransportMode(String code, TransportLine line, PowerSupply powerSupply) {
        this.code = code;
        this.line = line;
        this.powerSupply = powerSupply;
        this.isSuspended = false;
    }
    
    public void suspend() {
        this.isSuspended = true;
    }
    
    public void reactivate() {
        this.isSuspended = false;
    }

    // Getters and setters
    public String getCode() { return code; }
    public TransportLine getLine() { return line; }
    public PowerSupply getPowerSupply() { return powerSupply; }
    public double getKilometersTraveled() { return kilometersTraveled; }
    public boolean isSuspended() { return isSuspended; }
    public void setKilometersTraveled(double kilometersTraveled) { this.kilometersTraveled = kilometersTraveled; }
}package services;

import models.*;
import enums.ComplaintStatus;
import enums.SeverityLevel;
import java.time.LocalDateTime;
import java.time.temporal.ChronoUnit;
import java.util.List;
import java.util.stream.Collectors;

public class ComplaintService {
    public void processComplaint(Complaint complaint) {
        complaint.processComplaint();
        
        if (complaint instanceof TechnicalComplaint) {
            TechnicalComplaint techComplaint = (TechnicalComplaint) complaint;
            checkForSuspension(techComplaint);
        }
        
        // Simulate analysis within 24 hours
        if (ChronoUnit.HOURS.between(complaint.getReportDate(), LocalDateTime.now()) <= 24) {
            complaint.setStatus(ComplaintStatus.APPROVED); // Simplified for demo
        }
    }
    
    private void checkForSuspension(TechnicalComplaint complaint) {
        Station station = complaint.getStation();
        TransportMode transport = complaint.getTransport();
        
        if (complaint.getSeverity() == SeverityLevel.HIGH) {
            // Check for station complaints
            long highSeverityStationComplaints = station.getComplaints().stream()
                .filter(c -> c instanceof TechnicalComplaint)
                .filter(c -> ((TechnicalComplaint)c).getSeverity() == SeverityLevel.HIGH)
                .filter(c -> c.getStatus() == ComplaintStatus.APPROVED)
                .filter(c -> ChronoUnit.HOURS.between(c.getReportDate(), LocalDateTime.now()) <= 24)
                .count();
            
            if (highSeverityStationComplaints >= 3) {
                station.suspend();
            }
            
            // Check for transport complaints
            long highSeverityTransportComplaints = station.getComplaints().stream()
                .filter(c -> c instanceof TechnicalComplaint)
                .filter(c -> ((TechnicalComplaint)c).getTransport() == transport)
                .filter(c -> ((TechnicalComplaint)c).getSeverity() == SeverityLevel.HIGH)
                .filter(c -> c.getStatus() == ComplaintStatus.APPROVED)
                .filter(c -> ChronoUnit.HOURS.between(c.getReportDate(), LocalDateTime.now()) <= 24)
                .count();
            
            if (highSeverityTransportComplaints >= 3) {
                transport.suspend();
            }
        }
    }
    
    public void resolveComplaint(Complaint complaint) {
        complaint.setStatus(ComplaintStatus.RESOLVED);
        
        // Check if suspension can be lifted
        if (complaint instanceof TechnicalComplaint) {
            TechnicalComplaint techComplaint = (TechnicalComplaint) complaint;
            Station station = techComplaint.getStation();
            TransportMode transport = techComplaint.getTransport();
            
            long pendingHighSeverityStationComplaints = station.getComplaints().stream()
                .filter(c -> c instanceof TechnicalComplaint)
                .filter(c -> ((TechnicalComplaint)c).getSeverity() == SeverityLevel.HIGH)
                .filter(c -> c.getStatus() != ComplaintStatus.RESOLVED)
                .count();
            
            if (pendingHighSeverityStationComplaints == 0 && station.isSuspended()) {
                station.reactivate();
            }
            
            long pendingHighSeverityTransportComplaints = station.getComplaints().stream()
                .filter(c -> c instanceof TechnicalComplaint)
                .filter(c -> ((TechnicalComplaint)c).getTransport() == transport)
                .filter(c -> ((TechnicalComplaint)c).getSeverity() == SeverityLevel.HIGH)
                .filter(c -> c.getStatus() != ComplaintStatus.RESOLVED)
                .count();
            
            if (pendingHighSeverityTransportComplaints == 0 && transport.isSuspended()) {
                transport.reactivate();
            }
        }
    }
    
    public List<Complaint> getComplaintsByStation(Station station) {
        return station.getComplaints();
    }
    
    public List<Complaint> getComplaintsByTransport(TransportMode transport) {
        return transport.getLine().getStations().stream()
            .flatMap(s -> s.getComplaints().stream())
            .filter(c -> c instanceof TechnicalComplaint)
            .filter(c -> ((TechnicalComplaint)c).getTransport() == transport)
            .collect(Collectors.toList());
    }
}package services;

import models.*;
import enums.PaymentMethod;
import java.time.LocalDateTime;
import java.util.List;

public class FareService {
    public void sellFareMedium(Passenger passenger, Station station, 
                             FareMedium fareMedium, StationAgent agent) {
        agent.sellFareMedium(passenger, fareMedium);
    }
    
    public List<FareMedium> getPurchaseHistoryByStation(Station station) {
        return station.getSoldFareMedia();
    }
    
    public double calculateRevenueByPaymentMethod(PaymentMethod method) {
        return SystemManager.getInstance().getStations().stream()
            .flatMap(s -> s.getSoldFareMedia().stream())
            .filter(f -> f.getPaymentMethod() == method)
            .mapToDouble(FareMedium::getPrice)
            .sum();
    }
    
    public int countVisitors(Station station, LocalDateTime start, LocalDateTime end) {
        return (int) station.getValidatedFareMedia().stream()
            .filter(f -> f.getActivationDateTime() != null)
            .filter(f -> !f.getActivationDateTime().isBefore(start) && !f.getActivationDateTime().isAfter(end))
            .count();
    }
}package services;

public class NotificationService {
    public static void notifyPassengers(String message) {
        // In a real system, this would send notifications via app or station displays
        System.out.println("Notification: " + message);
    }
}package services;

import models.*;
import enums.PaymentMethod;
import java.time.DayOfWeek;
import java.time.LocalDateTime;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

public class ReportService {
    public Map<PaymentMethod, Double> generateRevenueReport() {
        return SystemManager.getInstance().getStations().stream()
            .flatMap(s -> s.getSoldFareMedia().stream())
            .collect(Collectors.groupingBy(
                FareMedium::getPaymentMethod,
                Collectors.summingDouble(FareMedium::getPrice)
            ));
    }
    
    public Map<String, Long> getComplaintStatisticsByStation(Station station) {
        return station.getComplaints().stream()
            .collect(Collectors.groupingBy(
                c -> c.getClass().getSimpleName(),
                Collectors.counting()
            ));
    }
    
    public Map<String, Long> getComplaintStatisticsByTransport(TransportMode transport) {
        return transport.getLine().getStations().stream()
            .flatMap(s -> s.getComplaints().stream())
            .filter(c -> c instanceof TechnicalComplaint)
            .filter(c -> ((TechnicalComplaint)c).getTransport() == transport)
            .collect(Collectors.groupingBy(
                c -> c.getClass().getSimpleName(),
                Collectors.counting()
            ));
    }
    
    public long countSuspendedStations(List<Station> stations) {
        return stations.stream()
            .filter(Station::isSuspended)
            .count();
    }
    
    public long countSuspendedTransports(List<TransportMode> transports) {
        return transports.stream()
            .filter(TransportMode::isSuspended)
            .count();
    }
    
    public Map<DayOfWeek, Long> getPeakOffPeakStats(Station station, LocalDateTime start, LocalDateTime end) {
        return station.getValidatedFareMedia().stream()
            .filter(f -> f.getActivationDateTime() != null)
            .filter(f -> !f.getActivationDateTime().isBefore(start) && !f.getActivationDateTime().isAfter(end))
            .collect(Collectors.groupingBy(
                f -> f.getActivationDateTime().getDayOfWeek(),
                Collectors.counting()
            ));
    }
}package services;

import models.*;
import enums.*;
import java.time.DayOfWeek;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;

public class SystemManager {
    private static SystemManager instance;
    private List<Station> stations;
    private List<TransportMode> transportModes;
    private List<Passenger> passengers;
    private List<Employee> employees;
    
    private FareService fareService;
    private ComplaintService complaintService;
    private ReportService reportService;
    
    private SystemManager() {
        this.stations = new ArrayList<>();
        this.transportModes = new ArrayList<>();
        this.passengers = new ArrayList<>();
        this.employees = new ArrayList<>();
        
        this.fareService = new FareService();
        this.complaintService = new ComplaintService();
        this.reportService = new ReportService();
    }
    
    public static SystemManager getInstance() {
        if (instance == null) {
            instance = new SystemManager();
        }
        return instance;
    }
    
    // Station management
    public void addStation(Station station) {
        stations.add(station);
    }
    
    // Transport management
    public void addTransportMode(TransportMode transport) {
        transportModes.add(transport);
    }
    
    // Passenger management
    public void registerPassenger(Passenger passenger) {
        passengers.add(passenger);
    }
    
    // Employee management
    public void hireEmployee(Employee employee) {
        employees.add(employee);
    }
    
    // Fare management
    public void processFareSale(Passenger passenger, Station station, 
                              FareMedium fareMedium, StationAgent agent) {
        fareService.sellFareMedium(passenger, station, fareMedium, agent);
    }
    
    // Complaint handling
    public void processComplaint(Complaint complaint) {
        complaintService.processComplaint(complaint);
    }
    
    // Reporting
    public void generateFareMediumReport(Station station) {
        List<FareMedium> history = fareService.getPurchaseHistoryByStation(station);
        System.out.println("Fare Medium Purchase History for " + station.getName() + ":");
        history.forEach(f -> System.out.println("ID: " + f.getId() + ", Price: " + f.getPrice() + ", Method: " + f.getPaymentMethod()));
    }
    
    public void generateRevenueReport() {
        Map<PaymentMethod, Double> report = reportService.generateRevenueReport();
        System.out.println("Revenue by Payment Method:");
        report.forEach((method, revenue) -> System.out.println(method + ": " + revenue));
    }
    
    public void analyzeTransportUsage(Station station, LocalDateTime start, LocalDateTime end) {
        int visitors = fareService.countVisitors(station, start, end);
        System.out.println("Visitors to " + station.getName() + " from " + start + " to " + end + ": " + visitors);
        
        Map<DayOfWeek, Long> peakStats = reportService.getPeakOffPeakStats(station, start, end);
        System.out.println("Peak/Off-Peak Statistics:");
        peakStats.forEach((day, count) -> System.out.println(day + ": " + count));
    }
    
    public void displayComplaintStatistics(Station station) {
        Map<String, Long> stats = reportService.getComplaintStatisticsByStation(station);
        System.out.println("Complaint Statistics for " + station.getName() + ":");
        stats.forEach((type, count) -> System.out.println(type + ": " + count));
    }
    
    public void displayComplaintStatistics(TransportMode transport) {
        Map<String, Long> stats = reportService.getComplaintStatisticsByTransport(transport);
        System.out.println("Complaint Statistics for Transport " + transport.getCode() + ":");
        stats.forEach((type, count) -> System.out.println(type + ": " + count));
    }
    
    public void displaySuspensionStatistics() {
        long suspendedStations = reportService.countSuspendedStations(stations);
        long suspendedTransports = reportService.countSuspendedTransports(transportModes);
        
        System.out.println("Suspended Stations: " + suspendedStations);
        System.out.println("Suspended Transport Modes: " + suspendedTransports);
    }
    
    public void suspendStation(Station station) {
        station.suspend();
        System.out.println("Station " + station.getName() + " suspended.");
    }

    public void suspendTransport(TransportMode transport) {
        transport.suspend();
        System.out.println("Transport " + transport.getCode() + " suspended.");
    }
    
    public void printPeakAndOffPeak() {
        // Example implementation: Define peak as 7-9 AM and 5-7 PM, off-peak otherwise
        for (Station station : stations) {
            System.out.println("Peak/Off-Peak for Station " + station.getName() + ":");
            long peakCount = station.getValidatedFareMedia().stream()
                .filter(f -> f.getActivationDateTime() != null)
                .filter(f -> {
                    int hour = f.getActivationDateTime().getHour();
                    return (hour >= 7 && hour < 9) || (hour >= 17 && hour < 19);
                })
                .count();
            long offPeakCount = station.getValidatedFareMedia().stream()
                .filter(f -> f.getActivationDateTime() != null)
                .filter(f -> {
                    int hour = f.getActivationDateTime().getHour();
                    return !((hour >= 7 && hour < 9) || (hour >= 17 && hour < 19));
                })
                .count();
            System.out.println("Peak Hours (7-9 AM, 5-7 PM): " + peakCount);
            System.out.println("Off-Peak Hours: " + offPeakCount);
        }
    }
    
    // Getters
    public List<Station> getStations() { return stations; }
    public List<TransportMode> getTransportModes() { return transportModes; }
    public List<Passenger> getPassengers() { return passengers; }
    public List<Employee> getEmployees() { return employees; }
    public ComplaintService getComplaintService() { return complaintService; }
    public FareService getFareService() { return fareService; }
    public ReportService getReportService() { return reportService; }
}import enums.*;
import java.time.LocalDateTime;
import java.time.LocalTime;
import java.time.Month;
import java.util.Arrays;
import models.*;
import services.*;

public class Main {
    public static void main(String[] args) {
        SystemManager manager = SystemManager.getInstance();

        // Setup stations
        Station station1 = new Station("S003", "Central", "Downtown", Zone.CENTER, 2);
        Station station2 = new Station("S004", "North Station", "Uptown", Zone.CENTER, 2);
        Station station3 = new Station("S005", "South Station", "Suburbs", Zone.BOTH, 2);
        manager.addStation(station1);
        manager.addStation(station2);
        manager.addStation(station3);

        // Setup transport line and mode
        TransportLine line = new TransportLine(1, 10.5,
                Arrays.asList(station1, station2, station3),
                LocalTime.of(6, 0), LocalTime.of(22, 0));
        TransportMode transport = new TransportMode("T005", line, PowerSupply.DIESEL);
        manager.addTransportMode(transport);

        // Setup employee
        StationAgent agent = new StationAgent(1, "Agent Smith", station1);
        manager.hireEmployee(agent);

        // Setup passenger
        Passenger p1 = new Passenger(1, "John Doe");
        Passenger p2 = new Passenger(2, "Jane Roe");
        manager.registerPassenger(p1);
        manager.registerPassenger(p2);

        // Sell and validate fare mediums
        FareMedium f1 = new FareMedium(1, "F001", Zone.CENTER, 120, PaymentMethod.CASH,
                LocalDateTime.of(2025, Month.APRIL, 3, 8, 15));
        FareMedium f2 = new FareMedium(2, "F002", Zone.BOTH, 200, PaymentMethod.DAHABIA_CARD,
                LocalDateTime.of(2025, Month.APRIL, 4, 9, 30));
        FareMedium f3 = new FareMedium(3, "F003", Zone.CENTER, 150, PaymentMethod.BARIDIMOB_APP,
                LocalDateTime.of(2025, Month.APRIL, 5, 10, 0));

        manager.processFareSale(p1, station1, f1, agent);
        manager.processFareSale(p2, station1, f2, agent);
        manager.processFareSale(p1, station1, f3, agent);

        // Validate fare media within the date range
        f1.validate();
        f1.setActivationDateTime(LocalDateTime.of(2025, Month.APRIL, 3, 8, 30));
        station1.validateFareMedium(f1);
        f2.validate();
        f2.setActivationDateTime(LocalDateTime.of(2025, Month.APRIL, 4, 9, 45));
        station1.validateFareMedium(f2);
        f3.validate();
        f3.setActivationDateTime(LocalDateTime.of(2025, Month.APRIL, 5, 10, 15));
        station1.validateFareMedium(f3);

        // Complaints
        TechnicalComplaint c1 = new TechnicalComplaint(112, "Issue", station1,
                TechnicalIssueType.GENERAL_FAILURE, transport);
        c1.setSeverity(SeverityLevel.HIGH);
        c1.setStatus(ComplaintStatus.APPROVED);
        c1.setDate(LocalDateTime.of(2025, Month.APRIL, 15, 14, 0));
        p1.submitComplaint(c1);
        station1.addComplaint(c1);
        manager.processComplaint(c1);

        Complaint c2 = new ServiceSafetyComplaint(113, "Theft", station1);
        c2.setSeverity(SeverityLevel.LOW);
        c2.setStatus(ComplaintStatus.REJECTED);
        c2.setDate(LocalDateTime.of(2025, Month.APRIL, 16, 12, 0));
        p2.submitComplaint(c2);
        station1.addComplaint(c2);
        manager.processComplaint(c2);

        TechnicalComplaint c3 = new TechnicalComplaint(114, "Fare Reader Issue", station1,
                TechnicalIssueType.FARE_READER, null);
        c3.setStatus(ComplaintStatus.RESOLVED);
        p1.submitComplaint(c3);
        station1.addComplaint(c3);
        manager.processComplaint(c3);

        TechnicalComplaint c4 = new TechnicalComplaint(115, "AC Failure", station1,
                TechnicalIssueType.GENERAL_FAILURE, transport);
        c4.setSeverity(SeverityLevel.HIGH);
        c4.setStatus(ComplaintStatus.APPROVED);
        c4.setDate(LocalDateTime.of(2025, Month.APRIL, 15, 15, 0));
        p1.submitComplaint(c4);
        station1.addComplaint(c4);
        manager.processComplaint(c4);

        TechnicalComplaint c5 = new TechnicalComplaint(116, "Schedule Display Issue", station1,
                TechnicalIssueType.GENERAL_FAILURE, transport);
        c5.setSeverity(SeverityLevel.HIGH);
        c5.setStatus(ComplaintStatus.APPROVED);
        c5.setDate(LocalDateTime.of(2025, Month.APRIL, 15, 16, 0));
        p1.submitComplaint(c5);
        station1.addComplaint(c5);
        manager.processComplaint(c5);

        // Add a Fare Payment complaint
        FarePaymentComplaint c6 = new FarePaymentComplaint(117, "Overcharged", station1, 50.0, PaymentMethod.BARIDIMOB_APP);
        c6.setSeverity(SeverityLevel.MEDIUM);
        c6.setStatus(ComplaintStatus.APPROVED);
        c6.setDate(LocalDateTime.of(2025, Month.APRIL, 16, 13, 0));
        p2.submitComplaint(c6);
        station1.addComplaint(c6);
        manager.processComplaint(c6);

        // Resolve some complaints to trigger reactivation
        manager.getComplaintService().resolveComplaint(c1);
        manager.getComplaintService().resolveComplaint(c4);
        manager.getComplaintService().resolveComplaint(c5);

        // Print Reports
        System.out.println("a.  Purchase History for Station " + station1.getName() + ":");
        System.out.println("----------------------------------------------------");
        manager.generateFareMediumReport(station1);

        System.out.println("...  Revenue Report:");
        System.out.println("---------------");
        manager.generateRevenueReport();

        System.out.println("Visitors at Station " + station1.getName() + " from 2025-04-01 to 2025-04-07:");
        System.out.println("-------------------------------------------------------------------");
        manager.analyzeTransportUsage(station1,
                LocalDateTime.of(2025, 4, 1, 0, 0),
                LocalDateTime.of(2025, 4, 7, 23, 59));

        System.out.println("Usage Statistics:");
        System.out.println("-----------------");
        manager.printPeakAndOffPeak();

        System.out.println("Complaints for Station " + station1.getName() + ":");
        System.out.println("---------------------------------------");
        manager.displayComplaintStatistics(station1);

        System.out.println("Complaints for Transport Code [" + transport.getCode() + "]:");
        System.out.println("--------------------------------------");
        manager.displayComplaintStatistics(transport);

        manager.displaySuspensionStatistics();

        // Print all complaints
        System.out.println("Complaint #C112 | Status: " + c1.getStatus() + " | Type: Technical | Severity: High | Concern: Transport " + transport.getCode() + " | Date: 2025-04-15");
        System.out.println("Complaint #C113 | Status: " + c2.getStatus() + " | Type: Service/Safety | Issue: Theft | Station: " + station1.getCode() + " | Date: 2025-04-16");
        System.out.println("Complaint #C114 | Status: " + c3.getStatus() + " | Type: Technical | Concern: Fare Reader | Station: " + station1.getCode());
        System.out.println("Complaint #C115 | Status: " + c4.getStatus() + " | Type: Technical | Severity: High | Concern: Transport " + transport.getCode() + " | Date: 2025-04-15");
        System.out.println("Complaint #C116 | Status: " + c5.getStatus() + " | Type: Technical | Severity: High | Concern: Transport " + transport.getCode() + " | Date: 2025-04-15");
        System.out.println("Complaint #C117 | Status: " + c6.getStatus() + " | Type: Fare Payment | Issue: Overcharged | Amount: 50.0 | Station: " + station1.getCode() + " | Date: 2025-04-16");
    }
}